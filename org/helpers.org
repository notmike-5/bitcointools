* Imports
#+begin_src python :tangle ../helpers.py :results silent :session pybtc

import binascii
import json
import random

MAX_COMPACT_SIZE = 2**64 - 1

#+end_src


* Conversions
#+begin_src python :tangle ../helpers.py :results silent :session pybtc

def bytes_to_hex(byte_str: bytes) -> int:
    '''Convert bytes to their hexadecimal representation'''
    try:
        return binascii.hexlify(byte_str).decode()
    except binascii.Error:
        raise ValueError(f"Invalid bytes: {byte_str}") from binascii.Error

def hex_to_ascii(hex_str: str) -> str:
    '''convert a hexadecimal value to its ascii equiv'''
    try:
        return bytes.fromhex(hex_str).decode('utf-8')
    except UnicodeDecodeError as e:
        return e

def hex_to_bytes(hex_str: int) -> bytes:
    '''Convert hex-encoded string to bytes'''
    try:
        return binascii.unhexlify(hex_str)
    except binascii.Error:
        raise ValueError(f"Invalid hex script: {hex_str}") from binascii.Error

def int_to_bytes(n: int, endian: str = 'big'):
    if not isinstance(n, int):
        raise ValueError("int_to_bytes: n must be an integer")
    if endian not in ('big', 'little'):
        raise ValueError("int_to_bytes: endian must be \'big\' (default) or \'little\'")
    return n.to_bytes((n.bit_length() + 7) // 8, endian)

# TODO refactor so this makes sense for what it does
def reverse_bytes(byte_str: bytes) -> bytes:
    '''Convert between big- and litttle-endian'''
    return bytes.fromhex(byte_str)[::-1].hex()

#+end_src


* Utility Functions
#+begin_src python :tangle ../helpers.py :results silent :session pybtc
def parse_varint(tx: bytes, cur: int) -> (int, int):
    '''Parse a variable-length integer from the transaction data
    and move cursor to appropriate position'''
    if tx[cur] not in list(range(0x0, 0xff)):
        raise ValueError(f'parse_varint called on invalid byte {tx[cur]}')
    if tx[cur] < 0xfd:
        return tx[cur], cur + 1
    if tx[cur] == 0xfd:
        return int.from_bytes(tx[cur+1:cur+3], 'little'), cur + 3
    if tx[cur] == 0xfe:
        return int.from_bytes(tx[cur+1:cur+5], 'little'), cur + 5
    # 0xff (rare)
    return int.from_bytes(tx[cur+1:cur+9], 'little'), cur + 9

# TODO: for tx inputs we would want the count of them
def get_compact_size(n: int=None) -> str:
    '''Get the compact size byte for given script.'''
    if isinstance(n, float) and n.is_integer():
        n = int(n)  # Convert integral floats to int
    if not isinstance(n, int) or not (0 <= n and n <= MAX_COMPACT_SIZE):  # max get_compact_size
        raise ValueError("get_compact_size: out of bounds! must be 0 <= n <= 0xffffffffffffffff")

    if n < 0xfd:                    # single-byte case when  size < 0xffff
        return hex(n)[2:].zfill(2)
    elif n <= 0xffff:
        return 'fd' + n.to_bytes(2, 'little').hex()
    elif n <= 0xffffffff:
        return 'fe' + n.to_bytes(4, 'little').hex()
    else: # n > 0xffffffff
        return 'ff' + n.to_bytes(8, 'little').hex()

def hash_sort(arr, n_buckets: int = 997):
    '''a very fast sorting algorithm for numeric data'''
    if arr is None:
        return []

    min_v, max_v = min(arr), max(arr)
    if min_v == max_v:
        return arr

    buckets =[[] for _ in range(n_buckets)]

    range_sz = max_v - min_v
    for n in arr:
        idx = int(((n - min_v) / range_sz) * (n_buckets - 1))
        buckets[idx].append(n)

    sorted_out = []
    for b in buckets:
        if len(b) == 1:
            sorted_out.append(b[0])
        else:
            b.sort()
            sorted_out.extend(b)

    return sorted_out

def get_tests(test_vector_file):
    '''helper to load test vectors given in json format'''
    with open(test_vector_file, 'r') as f:
        testdata = json.load(f)
        f.close()

    return testdata

#+end_src


* Tests
#+begin_src python :tangle ../helpers.py :results silent :session pybtc
def run_tests():
    '''Temporary testbench'''

    #
    # # Test Conversions
    #
    assert bytes_to_hex(b'\xde\xad\xbe\xef') == 'deadbeef'
    print(f"Expected: deadbeef\nGot:\t {bytes_to_hex(b'\xde\xad\xbe\xef')}")

    #
    # # Test Compact Sizes
    #
    for i in range(0, 252):
        msg = bytes(random.getrandbits(1) for _ in range(i))
        size_byte = get_compact_size(len(msg))
        if size_byte != f"{i:02x}" :
            print(f"Expected: {hex(i)}\tGot: {size_byte}")

    print("\nTesting get_compact_size()...\n")

    # n out of bounds, too teeny-tiny
    try:
        print(f"Expected: \nGot:\t {get_compact_size(-1)}")
    except ValueError:
        print("Caught an out of bounds input. Good.")

    for n, b in zip([253, 65535, 65536, 4294967295, 4294967296, 18446744073709551615],
                    ['fdfd00', 'fdffff', 'fe00000100', 'feffffffff', 'ff0000000010000000', 'ffffffffffffffffff']):
        compact_size = get_compact_size(n)
        assert compact_size == b
        print(f"Expected: {b}\nGot:\t {compact_size}")

    # n out of bounds, too bookoo
    try:
        print(f"Expected: \nGot:\t {get_compact_size(18446744073709551616)}")
    except ValueError:
        print("Caught an out of bounds input. Good.")

#+end_src


* Main
#+begin_src python :tangle ../helpers.py :results silent :session pybtc

if __name__ == '__main__':
    print("\nRunning tests for helpers.py...\n")
    run_tests()

#+end_src
