* Docs
Taproot Transaction

!!!make sure tweaked public key has an even y-coordinate (per BIP-340)!!!!

- txid
- hash
- version: \x00\x00\x00\x02 (for SegWit)
- size
- vsize
- weight
- locktime (0 for immediate spend)

Input:
 - txid 32-byte little-endian
 - vout 4-byte
 - scriptSig e.g. {"asm": _,
                   "hex": _ } (for SegWit)
 - txinwitness []
 - sequence typ. 0xffffffff

- vin: [input_0, input_1, ..., input_n]

- vout: [output_0, output_1, ..., output_n]
 - value
 - n
 - scriptPubkey eg {"asm": _,
                    "desc": _,
                    "hex": _,
                    "address": _,
                    "types": _ }

# Spending
Step 5: Sign the Transaction (Key-Path Spend)

    Compute the Sighash:
        Use BIP-341 sighash rules for Taproot.
        Sighash type: Typically SIGHASH_DEFAULT (0x00, covers all inputs/outputs).
        Serialize transaction data (version, inputs, outputs, etc.) per BIP-341.
        Hash with SHA256 to get the sighash.
    Sign with Schnorr:
        Use the private key corresponding to the internal public key.
        Generate a Schnorr signature (64 bytes) for the sighash.
        Example: signature = secp256k1.schnorr_sign(sighash, private_key).
    Construct Witness:
        For key-path spend: Witness stack contains only the 64-byte Schnorr signature.
        Example: [signature].

Step 6: (Optional) Script-Path Spend

If spending via a script path:

Select a Script:
        Choose a script from the Merkle tree committed in the output.
    Construct Control Block:
        Include the version (0x01 for Taproot), internal public key, and Merkle proof (path to the script’s leaf).
        Example: control_block = <version> || <internal_pubkey> || <merkle_path>.
        Witness Stack:
        Stack: [script_input, script, control_block].
        script_input satisfies the selected script (e.g., signatures for a multisig).

Step 7: Serialize the Transaction

    Transaction Format:
        Version (4 bytes).
        Marker and flag ( 0x00 0x01 for SegWit).
        Input count (varint).
        Inputs (txid, vout, scriptSig, sequence).
        Output count (varint).
        Outputs (amount, scriptPubKey).
        Witness data (for each input).
        Locktime (4 bytes).
    Serialize:
        Convert all fields to hex.
        Example (simplified): 0200000001<txid><vout><scriptSig><sequence>01<amount><scriptPubKey>0001<signature>00000000.

Step 8: Validate and Broadcast

    Validate Locally:
        Verify the transaction format and signatures using a Bitcoin library or node.
        Check that inputs cover outputs plus fees.
    Broadcast:
        Submit the transaction to the Bitcoin network via a node (e.g., bitcoin-cli sendrawtransaction <hex>).
        Alternatively, use a library to broadcast (e.g., bitcoinlib.network.broadcast_transaction).

Opcodes from 0x50 to 0x60 and 0x62 to 0x6F are reserved as OP_SUCCESSx


* Imports
#+begin_src python :tangle ../taproot.py :results silent :session pybtc

from bitcointools.hashes import tagged_hash
from bitcointools.helpers import bytes_to_hex, hex_to_bytes, get_compact_size, get_tests
import secp256k1

#+end_src


* Functions
#+begin_src python :tangle ../taproot.py :results silent :session pybtc

# secp256k1 curve order (for negation: -1 ≡ order - 1 mod order)
CURVE_ORDER = int('0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141', 16)

def negate_pubkey(pubkey: secp256k1.PublicKey) -> secp256k1.PublicKey:
    '''Negate a pubkey point (multiply by -1 on the curve)'''
    neg_scalar = (CURVE_ORDER - 1).to_bytes(32, 'big')  # -1 mod order
    return pubkey.tweak_mul(neg_scalar)

def tapleaf_hash(tapscript_ver: str = 'c0', script: str = None) -> str:
    '''Hash function for tapleaf'''
    if not script:
        print("Wat? You forgot the tap script.")
        return None
    script_bytes = hex_to_bytes(script)
    compact_size = get_compact_size(len(script_bytes))
    data_hex = tapscript_ver + compact_size + script
    data_bytes = hex_to_bytes(data_hex)
    return tagged_hash("TapLeaf", data_bytes).hex()

def tapbranch_hash(left, right):
    if left < right:
        return tagged_hash("TapBranch", hex_to_bytes(left) + hex_to_bytes(right))
    return tagged_hash("TapBranch", hex_to_bytes(right) + hex_to_bytes(left))

def collect_leaf_hashes(tree, hashes=None, debug=False):
    """Recursively collect leaf hashes in order (for verification)."""
    if hashes is None:
        hashes = []

    if isinstance(tree, dict):    # Leaf
        version = f"{tree['leafVersion']:x}"
        script = tree['script']
        h = tapleaf_hash(tapscript_ver=version, script=script)
        hashes.append(h)
        if debug:
            print(f"{script} => {h}")
    elif isinstance(tree, list):  # Branch: recurse on children
        for sub in tree:
            collect_leaf_hashes(sub, hashes, debug)
    else:
        raise ValueError("Invalid tree node")

    return hashes

def compute_merkle_root(tree):
    """Recursively compute taptree merkle root"""
    if isinstance(tree, dict):    # Leaf
        version = f"{tree['leafVersion']:x}"
        script = tree['script']
        return tapleaf_hash(tapscript_ver=version, script=script)

    elif isinstance(tree, list):  # Branch
        sub_roots = [compute_merkle_root(sub) for sub in tree]
        root = sub_roots[0]
        for h in sub_roots[1:]:
            root = tapbranch_hash(root, h)
        return root.hex()

    else:                         # badbadnotgood
        raise ValueError("Invalid tree node")

def compute_taproot_output(internal_pubkey, merkle_root):
    '''Compute the Taproot pubkey and scriptPubKey'''
    if len(internal_pubkey) != 32:
        raise ValueError("Internal pubkey must be 32 bytes")
    if len(merkle_root) != 32:
        raise ValueError("Merkle root must be 32 bytes")

    # compute the tweak
    tweak = tagged_hash("TapTweak", internal_pubkey + merkle_root)

    # tweak the pubkey
    pubkey = secp256k1.PublicKey(b'\x02' + internal_pubkey, raw=True)
    tweaked_pubkey = pubkey.tweak_add(tweak)

    # ensure even y-coordinate
    serialized = tweaked_pubkey.serialize()
    if serialized[0] == 0x03:  # odd y
        tweaked_pubkey = negate_pubkey(tweaked_pubkey)
        serialized = tweaked_pubkey.serialize()

    # extract x-only (32-bytes, dropped 0x02 prefix)
    xonly_tweaked_pubkey = serialized[1:]

    script_pubkey = b"\x51\x20" + xonly_tweaked_pubkey

    return tweak.hex(), xonly_tweaked_pubkey.hex(), script_pubkey.hex()

# TODO: test coverage on create_taproot_mast
def create_taproot_mast(internal_pubkey_hex, scripts):
    '''Create a Taproot MAST from scripts and internal pubkey'''
    try:
        internal_pubkey = hex_to_bytes(internal_pubkey_hex)
        merkle_root= compute_merkle_root(scripts)
        tweaked_pubkey, script_pubkey = compute_taproot_output(internal_pubkey, merkle_root)
        return {
            "merkle_root": bytes_to_hex(merkle_root),
            "tweaked_pubkey": bytes_to_hex(tweaked_pubkey),
            "script_pubkey": bytes_to_hex(script_pubkey)
        }
    except Exception as e:
        raise ValueError(f"Error creating Taproot MAST: {str(e)}") from e

#+end_src


* Test
** Test Vectors
*** BIP-0341 Tests
#+begin_src python :tangle ../taproot.py :results silent :session pybtc
def BIP341_tests():
    print("\nRunning Taproot (BIP-0341) Tests...")

    V = get_tests("bitcointools/test/bip341_wallet_test_vectors.json")

    #
    # BIP-341 - scriptPubKey Test Vectors
    #

    i=1
    for v in V['scriptPubKey']:
        print(f"\nBIP-341 Test Vector {i}\n", "-" * 25)
        i += 1

        # Extract the test data
        given, intermediary, expected = v['given'], v['intermediary'], v['expected']

        internal_pubkey = given['internalPubkey']
        script_tree = given['scriptTree']

        try:
            leaf_hashes = intermediary['leafHashes']
        except:
            pass

        merkle_root = intermediary['merkleRoot']

        tweak = intermediary['tweak']
        tweaked_pubkey = intermediary['tweakedPubkey']
        script_pubkey = expected['scriptPubKey']

        bip350_address = expected['bip350Address']

        try:
            script_path_control_blocks = expected['scriptPathControlBlocks']
        except:
            pass

        # Generate taptree

        # Case 1: Null taptree
        if script_tree is None:
            assert merkle_root is None
            assert script_pubkey == f"5120{tweaked_pubkey}"
            print("Null Script Tree")
            print(f"Merkle Root: {merkle_root}")
            print(f"scriptPubkey: {script_pubkey}")
            continue

        # Case 2: Single- and Multi-Leaf taptrees
        derived_hashes = collect_leaf_hashes(script_tree, debug=False)
        assert derived_hashes == leaf_hashes
        print(f"Leaf Hashes: {leaf_hashes}")

        derived_merkle_root = compute_merkle_root(script_tree)
        assert derived_merkle_root == merkle_root
        print(f"Merkle Root: {merkle_root}")

        # Generate tweak, tweakedPubKey, and scriptPubkey

        internal_pubkey_bytes, merkle_root_bytes = hex_to_bytes(internal_pubkey), hex_to_bytes(merkle_root)
        derived_tweak, derived_tweaked_pubkey, derived_script_pubkey = compute_taproot_output(internal_pubkey_bytes, merkle_root_bytes)

        assert derived_tweak == tweak
        assert derived_tweaked_pubkey == tweaked_pubkey
        assert derived_script_pubkey == script_pubkey

        print(f"Tweak is {tweak}")
        print(f"TweakedPubkey: {tweaked_pubkey}")
        print(f"ScriptPubkey: {script_pubkey}")

        # TODO: address encoding (covered in bech32.py, but move/re-create here)
        # TODO: verify scriptPathControlBlocks in scriptPubKey

    #
    # BIP-341 - keyPathSpending Test Vectors
    #

    print("\nAll BIP-341 Tests Passed Successfully!")
#+end_src

*** BIP-0360 Tests
#+begin_src python :tangle ../taproot.py :results silent :session pybtc
def BIP360_tests():
    print("\nRunning Taproot (BIP-0360) Tests...")

    V = get_tests("bitcointools/test/p2tsh_construction.json")

    #
    # BIP-360 - Test Vectors
    #

    i=1
    for v in V['test_vectors']:
        print(f"\nBIP-360 Test Vector {i}\n", "-" * 25)
        i += 1

        # Extract the test data
        id = v['id']
        objective = v['objective']


        # Given
        script_tree = v['given']['scriptTree']


        # Intermediary
        try:
            leaf_hashes = v['intermediary']['leafHashes']
        except:
            pass

        try:
            merkle_root = v['intermediary']['merkleRoot']
        except:
            merkle_root = None


        # Expected
        try:
            script_pubkey = v['expected']['scriptPubKey']
        except:
            script_pubkey = None

        try:
            bip350_address = v['expected']['bip350Address']
        except:
            pass

        try:
            script_path_control_blocks = v['expected']['scriptPathControlBlocks']
        except:
            pass

        try:
            error = v['expected']['error']
        except:
            pass


        # Generate taptree

        # Case 1: Null taptree
        if script_tree is None:
            assert merkle_root is None
            assert leaf_hashes == []
            assert script_pubkey is None
            print("Null Script Tree")
            print("Error: P2TSH requires a script tree with at least one leaf")
            continue

        # Case 2: Single- and Multi-Leaf taptrees
        derived_hashes = collect_leaf_hashes(script_tree, debug=False)
        assert derived_hashes == leaf_hashes
        print(f"Leaf Hashes: {leaf_hashes}")

        derived_merkle_root = compute_merkle_root(script_tree)
        assert derived_merkle_root == merkle_root
        print(f"Merkle Root: {merkle_root}")

        assert script_pubkey == f"5220{merkle_root}"
        print(f"ScriptPubkey: {script_pubkey}")

        print(f"\nPassed '{id}' with objective '{objective}'")

        # TODO verification of scriptPathControlBlocks in test_vectors

    print("\nAll BIP-360 Tests Passed Successfully!")

#+end_src

** Test Function
#+begin_src python :tangle ../taproot.py :results silent :session pybtc
def run_tests():
    BIP341_tests()
    BIP360_tests()

#+end_src


* Main
#+begin_src python :tangle ../taproot.py :results silent :session pybtc

if __name__ == '__main__':
    run_tests()

#+end_src
