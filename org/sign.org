* Imports
#+begin_src python :tangle ../sign.py :results silent :session pybtc

from hashes import sha256, tagged_hash
from helpers import get_compact_size, serialize_varbytes
from transaction import OutPoint, Transaction, TxOut

#+end_src

* SigHash Types
# Hash Type #

# The hash type byte indicates how much of the transaction you want to sign.

# The amount of the transaction you sign determines whether other people can add or remove inputs and outputs from your signed transaction.

| Byte | Type                              | Description                                  |
|------+-----------------------------------+----------------------------------------------|
| 0x01 | SIGHASH_ALL                        | Sign all inputs and outputs                  |
| 0x02 | SIGHASH_NONE                       | Sign all inputs only                         |
| 0x03 | SIGHASH_SINGLE                     | Sign all inputs and one corresponding output |
| 0x81 | SIGHASH_ANYONECANPAY SIGHASH_ALL    | Sign one input and all outputs               |
| 0x82 | SIGHASH_ANYONECANPAY SIGHASH_NONE   | Sign one input only                          |
| 0x83 | SIGHASH_ANYONECANPAY SIGHASH_SINGLE | Sign one input and one corresponding output  |


#+begin_src python :tangle ../sign.py :results silent :session pybtc

# SigHash Types
SIGHASH_DEFAULT = 0x0  # Taproot only; implied when sighash byte is missing, and equivalent to SIGHASH_ALL
SIGHASH_ALL = 0x1  # sign all inputs and outputs
SIGHASH_NONE = 0x2  # sign all inputs only
SIGHASH_SINGLE = 0x3  # sign all inputs and one corresponding output
SIGHASH_ANYONECANPAY = 0x80  #

# You can use logical operations to combine these into the other types
# SIGHASH_ANYONECANPAY | SIGHASH_ALL = b'0x81'   # sign one input and all outputs
# SIGHASH_ANYONECANPAY | SIGHASH_NONE = b'0x82'   # sign one input only
# SIGHASH_ANYONECANPAY | SIGHASH_SINGLE = b'0x83'  # sign one input and one corresponding output

SIGHASH_TYPES = [
    SIGHASH_DEFAULT,
    SIGHASH_ALL,
    SIGHASH_NONE,
    SIGHASH_SINGLE,
    SIGHASH_ANYONECANPAY | SIGHASH_ALL,
    SIGHASH_ANYONECANPAY | SIGHASH_NONE,
    SIGHASH_ANYONECANPAY | SIGHASH_SINGLE
]

EMPTY_HASH32 = b'\x00' * 32


def is_valid_hashtype(hash_type: int) -> bool:
    '''make sure we have a valid sighash type'''
    return hash_type in SIGHASH_TYPES

#+end_src

* Utility functions
#+begin_src python :tangle ../sign.py :results silent :session pybtc

class SigningContext:
    '''class to contain the nuts and bolts context needed to produce a sighash'''

    def __init__(self, tx: Transaction, utxos: dict[OutPoint, TxOut]) -> None:
        self.tx = tx
        self.utxos = utxos

        # (Pre)Compute / Cache Expensive Hashes
        ########################################
        # all input prevouts
        self.hash_prevouts = sha256(b''.join(
            txin.prevout.serialize() for txin in tx.inputs
        ))
        # all input amounts
        self.hash_amounts = sha256(b''.join(
            self.utxos[txin.prevout].amount.to_bytes(8, byteorder='little') for txin in tx.inputs
        ))

        # all input scriptPubkeys
        self.hash_scriptPubkeys = sha256(b''.join(
            serialize_varbytes(utxos[txin.prevout].scriptPubkey) for txin in tx.inputs
        ))

        # all input sequences
        self.hash_sequences = sha256(b''.join(
            txin.sequence.to_bytes(4, byteorder='little') for txin in tx.inputs
        ))

        # all tx outputs
        self.hash_outputs = sha256(b''.join(
            txout.serialize() for txout in tx.outputs
        ))

        # pre-compute per-input serialization for ANYONECANPAY
        self.serialized_inputs = []
        for txin in tx.inputs:
            s = (txin.prevout.serialize() +              # OutPoint = (txid, vout)
                 self.utxos[txin.prevout].serialize() +  # amount & scriptPubkey from OutPoint
                 txin.sequence.to_bytes(4, 'little'))    # sequence, 4-byte little-endian
            self.serialized_inputs.append(s)


    def taproot_sign(self, input_idx: int, sighash_type: int = SIGHASH_DEFAULT, ext_flag: int = 0, annex: bytes = None, message_ext: bytes = None) -> bytes:
        '''compute the BIP-341 / Taproot Common Signature Message ('sighash') for given input index.'''

        # Get the signature type
        base_type = sighash_type & 0x3
        anyone_can_pay = sighash_type & SIGHASH_ANYONECANPAY

        # Sanity Check
        if annex and annex[0] != 0x50:
            raise ValueError("Annex must start with 0x50")
        if ext_flag != 0:
            raise ValueError("ext_flag must be 0 until a softfork defines otherwise")
        if message_ext:
            raise ValueError("message_ext must be empty until defined otherwise")
        if not is_valid_hashtype(sighash_type):
            raise ValueError(f"Unknown sighash type: {sighash_type}")
        if (base_type == SIGHASH_SINGLE) and (input_idx >= len(self.tx.outputs)):
            raise ValueError("SIGHASH_SINGLE without corresponding output")

        # inputs
        if not anyone_can_pay:
            # previous outpoints
            hash_prevouts = self.hash_prevouts
            # amounts
            hash_amounts = self.hash_amounts
            # scriptPubkey
            hash_scriptPubkeys = self.hash_scriptPubkeys
            # sequences
            hash_sequences = self.hash_sequences
        else:
            # else its 32 bytes of zero, baby
            hash_prevouts = hash_amounts = hash_scriptPubkeys = hash_sequences = EMPTY_HASH32

        # outputs
        if base_type == SIGHASH_ALL:  # sign all outputs
            hash_outputs = self.hash_outputs
        elif base_type == SIGHASH_SINGLE:  # sign one output corresponding to input_idx
            hash_outputs = sha256(self.tx.outputs[input_idx].serialize())
        else:  # otherwise - believe it or not - its 32 bytes of zero
            hash_outputs = EMPTY_HASH32

        # annex
        if annex_present := bool(annex):
            annex = serialize_varbytes(annex)
            hash_annex = sha256(annex)
        else:
            hash_annex = b''


        # Construct the Common Signature Message
        ########################################
        message = b'\x00'  # epoch
        message += sighash_type.to_bytes(1, 'little')  # hash type
        message += self.tx.version.to_bytes(4, 'little')  # version
        message += self.tx.locktime.to_bytes(4, 'little')  # nLocktime

        if not anyone_can_pay:
            message += hash_prevouts
            message += hash_amounts
            message += hash_scriptpubkeys
            message += hash_sequences

        if base_type not in [SIGHASH_NONE, SIGHASH_SINGLE]:
            message += hash_outputs

        # spend type
        message += (2 * ext_flag + (1 if annex_present else 0)).to_bytes(1, 'little')

        # full serialization of this input
        if anyone_can_pay:
            message += self.serialized_inputs[input_idx]
        else:
            message += input_idx.to_bytes(4, 'little')  # index of input being signed for

        # annex serialization
        message += annex

        # SIGHASH_SINGLE output serialization
        if base_type == SIGHASH_SINGLE:
             txout = self.tx.outputs[input_idx]
             message += txout.serialize()

        # message extension (currently always empty if we got to here)
        if message_ext:
            message += message_ext

        return tagged_hash("TapSighash", message)

#+end_src

* SigHash Construction
#+begin_src python :tangle ../sign.py :results silent :session pybtc

#+end_src
